"use strict";(self.webpackChunkapi_extractor_com=self.webpackChunkapi_extractor_com||[]).push([[3728],{158:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>u});var n=a(6393);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=p(a),h=r,u=m["".concat(s,".").concat(h)]||m[h]||d[h]||o;return a?n.createElement(u,i(i({ref:t},c),{},{components:a})):n.createElement(u,i({ref:t},c))}));function u(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,i=new Array(o);i[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[m]="string"==typeof e?e:r,i[1]=l;for(var p=2;p<o;p++)i[p]=a[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},1301:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>l,metadata:()=>p,toc:()=>m});var n=a(9122),r=a(2501),o=(a(6393),a(158)),i=["components"],l={title:"Architecture notes"},s=void 0,p={unversionedId:"pages/contributing/architecture",id:"pages/contributing/architecture",title:"Architecture notes",description:"If you're interested in contributing, here's some general architectural notes that will hopefully help you find",source:"@site/docs/pages/contributing/architecture.md",sourceDirName:"pages/contributing",slug:"/pages/contributing/architecture",permalink:"/pages/contributing/architecture",draft:!1,editUrl:"https://github.com/microsoft/rushstack-websites/tree/main/websites/api-extractor.com/docs/pages/contributing/architecture.md",tags:[],version:"current",frontMatter:{title:"Architecture notes"},sidebar:"docsSidebar",previous:{title:"Debugging",permalink:"/pages/contributing/debugging"}},c={},m=[{value:"Project anatomy",id:"project-anatomy",level:2},{value:"Data flow",id:"data-flow",level:2}],d={toc:m},h="wrapper";function u(e){var t=e.components,a=(0,r.Z)(e,i);return(0,o.kt)(h,(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"If you're interested in contributing, here's some general architectural notes that will hopefully help you find\nyour way around the code base. (By the way, if you'd like to see more detail about specific aspects or topics,\nplease let use know by creating a GitHib issue in the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/microsoft/api-extractor.com-website/"},"api-extractor.com-website")," repo.)"),(0,o.kt)("h2",{id:"project-anatomy"},"Project anatomy"),(0,o.kt)("p",null,"API Extractor's code is separated into source code folders that reflect subsystems that can be arranged\ninto a rough overall operational flow."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("a",{parentName:"p",href:"https://github.com/microsoft/rushstack/tree/main/apps/api-extractor/src/cli"},"src/cli")," -\nthe command-line interface (CLI) that gets things started")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("a",{parentName:"p",href:"https://github.com/microsoft/rushstack/tree/main/apps/api-extractor/src/api"},"src/api")," -\nthis folder contains the public API such as ",(0,o.kt)("inlineCode",{parentName:"p"},"Extractor")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"ExtractorConfig"),". The CLI invokes these\nAPIs the same way that an external consumer would; it doesn't use any special internals. The TypeScript\ncompiler gets configured in this stage, producing the ",(0,o.kt)("inlineCode",{parentName:"p"},"ts.Program")," object that will be used below.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("a",{parentName:"p",href:"https://github.com/microsoft/rushstack/tree/main/apps/api-extractor/src/collector"},"src/collector")," -\nThe ",(0,o.kt)("inlineCode",{parentName:"p"},"Collector"),' acts as a central orchestrator that runs many of the stages below. Conceptually it is "collecting"\nall the API information in a central place, primarily ',(0,o.kt)("inlineCode",{parentName:"p"},"CollectorEntity")," objects. This folder also has the\n",(0,o.kt)("inlineCode",{parentName:"p"},"MessageRouter")," class that routes errors and warnings based on the ",(0,o.kt)("inlineCode",{parentName:"p"},'"messages"')," table from ",(0,o.kt)("strong",{parentName:"p"},"api-extractor.json"),".")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("a",{parentName:"p",href:"https://github.com/microsoft/rushstack/tree/main/apps/api-extractor/src/analyzer"},"src/analyzer")," -\nthe core analyzer, which traverses the TypeScript compiler's abstract syntax tree (AST) and produces\nthe higher-level representations used by API Extractor. There are 4 major pieces of tech here:"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The ",(0,o.kt)("inlineCode",{parentName:"p"},"AstSymbol")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"AstDeclaration")," classes, which mirror the compiler's ",(0,o.kt)("inlineCode",{parentName:"p"},"ts.Symbol")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"ts.Declaration"),"\nclasses. The difference is that an ",(0,o.kt)("inlineCode",{parentName:"p"},"AstDeclaration"),' node is only generated for a subset of interesting nodes\n(e.g. classes, enums, interfaces, etc.) that will become "API items" in the documentation website and its\n',(0,o.kt)("inlineCode",{parentName:"p"},"api-extractor-model")," representation. This condensed tree omits all the intermediary ",(0,o.kt)("inlineCode",{parentName:"p"},"ts.Declaration"),"\nnodes (e.g. ",(0,o.kt)("inlineCode",{parentName:"p"},"extends")," clauses, ",(0,o.kt)("inlineCode",{parentName:"p"},":")," tokens, and so forth). The\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/microsoft/rushstack/blob/main/apps/api-extractor/src/analyzer/AstSymbol.ts"},"AstSymbol.ts"),"\ncode comments provide some more detail about this very important data structure.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The ",(0,o.kt)("inlineCode",{parentName:"p"},"ExportAnalyzer"),", which traverses chains of TypeScript ",(0,o.kt)("inlineCode",{parentName:"p"},"import")," statements, eliminating the\nintermediary symbol aliases to build a flattened view as seen in the .d.ts rollup. The problem is\nthat the compiler's API makes it difficult to detect when this traversal leaves the working package\n(e.g. hops into the ",(0,o.kt)("inlineCode",{parentName:"p"},"node_modules")," folder or compiler's runtime library). That's why this file has special\nhandling for each kind of import syntax. The ",(0,o.kt)("inlineCode",{parentName:"p"},"export * from")," construct is by far the most complicated form.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Span")," class, which is a fairly lame but fairly effective utility for rewriting TypeScript source code\nwhile ignoring most of its meaning except for specific node types that we recognize. API Extractor does not\nuse the compiler's emitter to write .d.ts files, partially because those API were not public when we\nstarted, but also because it more faithfully preserves the original .d.ts inputs. The\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/microsoft/rushstack/blob/716b063f20fd3df82cf8436eeb2528789b0b7c37/apps/api-extractor/src/generators/DtsRollupGenerator.ts#L154"},"DtsRollupGenerator.","_","modifySpan()"),"\nfunction is a good illustration of how ",(0,o.kt)("inlineCode",{parentName:"p"},"Span")," is used.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The ",(0,o.kt)("inlineCode",{parentName:"p"},"AstReferenceResolver"),": Given a TSDoc declaration reference, this walks the the ",(0,o.kt)("inlineCode",{parentName:"p"},"AstSymbolTable")," to\nfind whatever it refers to.")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("a",{parentName:"p",href:"https://github.com/microsoft/rushstack/tree/main/apps/api-extractor/src/enhancers"},"src/enhancers")," -\nAfter the ",(0,o.kt)("inlineCode",{parentName:"p"},"Collector")," has collected all the API objects and their metadata, we run a series of additional\npostprocessing stages called ",(0,o.kt)("inlineCode",{parentName:"p"},"enhancers"),". The current ones are ",(0,o.kt)("inlineCode",{parentName:"p"},"ValidationEnhancer")," (which applies some\nAPI validation rules) and ",(0,o.kt)("inlineCode",{parentName:"p"},"DocCommentEnhancer")," which tunes up the TSDoc comments, for example expanding\nthe ",(0,o.kt)("inlineCode",{parentName:"p"},"@inheritDoc")," references.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("a",{parentName:"p",href:"https://github.com/microsoft/rushstack/tree/main/apps/api-extractor/src/generators"},"src/generators")," -\nThis folder implements API Extractor's famous 3 output types: ",(0,o.kt)("inlineCode",{parentName:"p"},"ApiReportGenerator"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"DtsRollupGenerator"),",\nand ",(0,o.kt)("inlineCode",{parentName:"p"},"ApiModelGenerator"),".")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("a",{parentName:"p",href:"https://github.com/microsoft/rushstack/tree/main/apps/api-extractor/src/schemas"},"src/schemas")," -\nThis folder contains the ",(0,o.kt)("inlineCode",{parentName:"p"},"api-extractor init")," template file, the JSON schema for ",(0,o.kt)("strong",{parentName:"p"},"api-extractor.json"),",\nand ",(0,o.kt)("strong",{parentName:"p"},"api-extractor-defaults.json")," which represents the default values for ",(0,o.kt)("strong",{parentName:"p"},"api-extractor.json")," settings."))),(0,o.kt)("h2",{id:"data-flow"},"Data flow"),(0,o.kt)("p",null,"Another useful way to understand API Extractor is by examining what happens to a declaration as it\ngets transformed by each stage. Consider a simple ",(0,o.kt)("inlineCode",{parentName:"p"},"function")," declaration that has two overloads:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { Report } from 'reporting-package';\n\n/** Declaration 1 */\nexport declare function add(report: Report, amount: number): void;\n\n/** Declaration 2 */\nexport declare function add(report: Report, title: string): void;\n")),(0,o.kt)("p",null,"Here's how it gets processed:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Compiler stage:")," The TypeScript compiler engine parses the .d.ts file into two ",(0,o.kt)("inlineCode",{parentName:"p"},"ts.Declaration")," objects\n(one for each overload) representing the parsed syntax. The compiler's analyzer then makes an associated\n",(0,o.kt)("inlineCode",{parentName:"p"},"ts.Symbol"),' which represents the function\'s type. Each TypeScript type always becomes exactly one symbol,\nand in this case with two associated declarations (the two overloads). There will also be many\n"aliases" for this symbol. For example, if we write ',(0,o.kt)("inlineCode",{parentName:"p"},'import { add } from "./math"'),", the word ",(0,o.kt)("inlineCode",{parentName:"p"},"add")," here becomes\na symbol alias whose declaration is that ",(0,o.kt)("inlineCode",{parentName:"p"},"import"),' statement. If we follow the chain of symbol aliases (perhaps\nthrough many imports and exports), we will always reach the unique "followed symbol" corresponding to the original\nreal definition of ',(0,o.kt)("inlineCode",{parentName:"p"},"add()"),".")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Analyzer stage:"),' API Extractor starts from your API entry point and follows each export to find its\n"followed symbol". Then we make an ',(0,o.kt)("inlineCode",{parentName:"p"},"AstSymbol")," and two ",(0,o.kt)("inlineCode",{parentName:"p"},"AstDeclaration"),"'s for ",(0,o.kt)("inlineCode",{parentName:"p"},"add()"),". The analyzer also walks up\nand down the AST tree to fill out the context. For example, if the ",(0,o.kt)("inlineCode",{parentName:"p"},"AstSymbol")," is a ",(0,o.kt)("inlineCode",{parentName:"p"},"class"),", then we'll create\na child ",(0,o.kt)("inlineCode",{parentName:"p"},"AstSymbol")," for each of its members. And if the class belongs to a ",(0,o.kt)("inlineCode",{parentName:"p"},"namespace"),", then a parent ",(0,o.kt)("inlineCode",{parentName:"p"},"AstSymbol"),"\nis added representing the namespace."),(0,o.kt)("p",{parentName:"li"},"While following ",(0,o.kt)("inlineCode",{parentName:"p"},"import")," statements, if we reach an external NPM package, the analysis stops there and\nproduces an ",(0,o.kt)("inlineCode",{parentName:"p"},"AstImport")," instead of a regular ",(0,o.kt)("inlineCode",{parentName:"p"},"AstSymbol"),". This is because API Extractor understands\npackage boundaries, and in fact is designed to be invoked separately on each project. Thus, in the above example,\n",(0,o.kt)("inlineCode",{parentName:"p"},"Report")," would become an ",(0,o.kt)("inlineCode",{parentName:"p"},"AstImport")," instead of an ",(0,o.kt)("inlineCode",{parentName:"p"},"AstSymbol"),". The analyzer's overall job is to pick through\nthe extremely detailed compiler data structures and produce a simplified tree of ",(0,o.kt)("inlineCode",{parentName:"p"},"AstSymbol")," objects. This\nalgorithm is the most complex stage of API Extractor, so we try to keep it isolated and single-purpose.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Collector stage:")," The collector builds the inventory of things that will end up as top-level items\nin the .d.ts rollup. We call these ",(0,o.kt)("inlineCode",{parentName:"p"},"CollectorEntity")," objects, and there is one for our ",(0,o.kt)("inlineCode",{parentName:"p"},"add()")," function,\nand another one for the ",(0,o.kt)("inlineCode",{parentName:"p"},"Report")," import. So ",(0,o.kt)("inlineCode",{parentName:"p"},"AstSymbol")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"AstImport")," can become a ",(0,o.kt)("inlineCode",{parentName:"p"},"CollectorEntity"),".\nBut note that ",(0,o.kt)("inlineCode",{parentName:"p"},"AstDeclaration")," cannot, nor can ",(0,o.kt)("inlineCode",{parentName:"p"},"AstModule")," (the analyzer's representation of a .d.ts source file).\nTo keep this straight, the analyzer's objects inherit from the ",(0,o.kt)("inlineCode",{parentName:"p"},"AstEntity")," base class if-and-only-if they\ncan become a ",(0,o.kt)("inlineCode",{parentName:"p"},"CollectorEntity"),". The ",(0,o.kt)("inlineCode",{parentName:"p"},"CollectorEntity")," wraps ",(0,o.kt)("inlineCode",{parentName:"p"},"AstEntity")," and appends some additional\ncollector stage information:"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Whether the entity is an ",(0,o.kt)("inlineCode",{parentName:"li"},"export")," of your .d.ts rollup or just a local declaration."),(0,o.kt)("li",{parentName:"ul"},"The local name in the .d.ts rollup, since local declarations may need to get renamed\nby ",(0,o.kt)("inlineCode",{parentName:"li"},"DtsRollupGenerator._makeUniqueNames()")," to avoid naming conflicts"),(0,o.kt)("li",{parentName:"ul"},"The export name(s) which can be different from the local name. For example:\n",(0,o.kt)("inlineCode",{parentName:"li"},"export { A as B, A as C }"),"."))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Enhancers stage:")," The enhancers mostly work with the ",(0,o.kt)("inlineCode",{parentName:"p"},"DeclarationMetadata"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"ApiItemMetadata"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"SymbolMetadata"),"\nobjects. These objects are stored on ",(0,o.kt)("inlineCode",{parentName:"p"},"AstSymbol")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"AstDeclaration"),", but they are entirely owned by the collector\nstage.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"ApiReportGenerator and DtsRollupGenerator:")," These generators essentially just dump the ",(0,o.kt)("inlineCode",{parentName:"p"},"CollectorEntity"),"\nitems into a big text file, but with different formatting. Other than trimming items according to release type,\nthey don't do much processing.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"api-extractor-model stage:")," The ",(0,o.kt)("strong",{parentName:"p"},"@microsoft/api-extractor-model")," package is completely independent and does not\nrely on any of the other API Extractor types described above. It defines the portable .api.json file format.\nIt has its own rich hierarchy inheriting from the ",(0,o.kt)("inlineCode",{parentName:"p"},"ApiItem")," base class (mixin inheritance actually): ",(0,o.kt)("inlineCode",{parentName:"p"},"ApiClass"),",\n",(0,o.kt)("inlineCode",{parentName:"p"},"ApiNamespace"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"ApiParameter"),", etc. In our example, the ",(0,o.kt)("inlineCode",{parentName:"p"},"add()")," function will become an ",(0,o.kt)("inlineCode",{parentName:"p"},"ApiFunction")," item\nin this representation. This model is designed to make it easy for third parties to generate documentation without\nhaving to understand the thorny compiler data structures. Thus the ",(0,o.kt)("inlineCode",{parentName:"p"},"ApiModelGenerator")," takes our ",(0,o.kt)("inlineCode",{parentName:"p"},"CollectorEntity"),"\nfor ",(0,o.kt)("inlineCode",{parentName:"p"},"add()")," and converts it into an ",(0,o.kt)("inlineCode",{parentName:"p"},"ApiFunction")," that will get serialized into .api.json."),(0,o.kt)("p",{parentName:"li"},"Recall that the analyzer internally used the ",(0,o.kt)("inlineCode",{parentName:"p"},"AstReferenceResolver")," helper to look up TSDoc declaration references\nand find the target ",(0,o.kt)("inlineCode",{parentName:"p"},"AstDeclaration"),". For the .api.json files, ",(0,o.kt)("strong",{parentName:"p"},"@microsoft/api-extractor-model")," provides\nan analogous ",(0,o.kt)("inlineCode",{parentName:"p"},"ModelReferenceResolver")," helper that looks up ",(0,o.kt)("inlineCode",{parentName:"p"},"ApiItem")," targets.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"API Documenter stage:")," Okay, one final transformation happens here. It's the last one! :-) When API Documenter\nloads up the .api.json file, it does not render it directly to .md files. First it converts the ",(0,o.kt)("inlineCode",{parentName:"p"},"ApiFunction"),"\nfor our ",(0,o.kt)("inlineCode",{parentName:"p"},"add()")," example function into a tree of TSDoc ",(0,o.kt)("inlineCode",{parentName:"p"},"DocNode")," elements. Normally ",(0,o.kt)("inlineCode",{parentName:"p"},"DocNode")," is used to represent\ndoc comments. But it happens to be a full DOM-like structure that can represent rich text. Since the TSDoc comment\nfor ",(0,o.kt)("inlineCode",{parentName:"p"},"add()")," is already this kind of rich text, API Documenter cleverly reuses this representation to model an\nentire web page. This intermediate representation enables the markdown emitter to be decoupled from the documentation\nengine, and makes it easy in the future to output other formats such as HTML or React."))),(0,o.kt)("p",null,"To summarize, for the humble ",(0,o.kt)("inlineCode",{parentName:"p"},"add()")," function this pipeline produced a number of different representations:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"AstDeclaration")," for the overload declarations"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"AstSymbol")," for the TypeScript type"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"CollectorEntity")," for the entry in the .d.ts file"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"DeclarationMetadata"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"ApiItemMetadata"),", and ",(0,o.kt)("inlineCode",{parentName:"li"},"SymbolMetadata")," to annotate the symbol and declaration with more info"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ApiFunction")," for the .api.json file"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"DocNode")," subtree for the documentation website")))}u.isMDXComponent=!0}}]);