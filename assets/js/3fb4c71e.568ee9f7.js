"use strict";(self.webpackChunkapi_extractor_com=self.webpackChunkapi_extractor_com||[]).push([[6340],{158:(e,t,n)=>{n.d(t,{Zo:()=>l,kt:()=>f});var r=n(6393);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=r.createContext({}),p=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},l=function(e){var t=p(e.components);return r.createElement(c.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),m=p(n),u=o,f=m["".concat(c,".").concat(u)]||m[u]||d[u]||a;return n?r.createElement(f,i(i({ref:t},l),{},{components:n})):r.createElement(f,i({ref:t},l))}));function f(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=u;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[m]="string"==typeof e?e:o,i[1]=s;for(var p=2;p<a;p++)i[p]=n[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},4742:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>c,default:()=>f,frontMatter:()=>s,metadata:()=>p,toc:()=>m});var r=n(9122),o=n(2501),a=(n(6393),n(158)),i=["components"],s={title:"API documentation"},c=void 0,p={unversionedId:"pages/overview/demo_docs",id:"pages/overview/demo_docs",title:"API documentation",description:'This article continues the tutorial from the "What is API Extractor?" page. It\'s recommended to start there.',source:"@site/docs/pages/overview/demo_docs.md",sourceDirName:"pages/overview",slug:"/pages/overview/demo_docs",permalink:"/pages/overview/demo_docs",draft:!1,editUrl:"https://github.com/microsoft/rushstack-websites/tree/main/websites/api-extractor.com/docs/pages/overview/demo_docs.md",tags:[],version:"current",frontMatter:{title:"API documentation"},sidebar:"docsSidebar",previous:{title:"The .d.ts rollup",permalink:"/pages/overview/demo_rollup"},next:{title:"Invoking API Extractor",permalink:"/pages/setup/invoking"}},l={},m=[{value:"What&#39;s in the JSON file?",id:"whats-in-the-json-file",level:2},{value:"Documenting multiple projects together",id:"documenting-multiple-projects-together",level:2}],d={toc:m},u="wrapper";function f(e){var t=e.components,n=(0,o.Z)(e,i);return(0,a.kt)(u,(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},'This article continues the tutorial from the "',(0,a.kt)("a",{parentName:"em",href:"/pages/overview/intro"},"What is API Extractor?"),"\" page. It's recommended to start there.")),(0,a.kt)("p",null,"The final API Extractor output that we'll look at is the \"",(0,a.kt)("strong",{parentName:"p"},"doc model"),'" file. This JSON file captures\nthe API signatures and doc comments for a project that was processed by API Extractor. It contains all the\ninformation needed to generate an API reference website.'),(0,a.kt)("p",null,"The website can be generated using the basic ",(0,a.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/@microsoft/api-documenter"},"api-documenter")," tool that comes with API Extractor. You can also\nuse the JSON files as an input for your own custom pipeline. For example, real ",(0,a.kt)("strong",{parentName:"p"},"@microsoft/sp-core-library"),"\ngets rendered using Microsoft's custom DocFX engine. Here's the final result:"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/javascript/api/sp-core-library"},"https://docs.microsoft.com/en-us/javascript/api/sp-core-library")),(0,a.kt)("h2",{id:"whats-in-the-json-file"},"What's in the JSON file?"),(0,a.kt)("p",null,"Since the NPM package name for our example project is ",(0,a.kt)("strong",{parentName:"p"},"@microsoft/sp-core-library"),", the default path for this\noutput will be ",(0,a.kt)("strong",{parentName:"p"},"temp/sp-core-library.api.json"),". The file is fairly large, but here's an excerpt\ncorresponding to the ",(0,a.kt)("inlineCode",{parentName:"p"},"ILogHandler.error")," member, which should give an idea of the file structure:"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"temp/sp-core-library.api.json"),(0,a.kt)("br",null)),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'{\n  "metadata": {\n    "toolPackage": "@microsoft/api-extractor",\n    "toolVersion": "7.1.0",\n    "schemaVersion": 1000\n  },\n  "kind": "Package",\n  "canonicalReference": "@microsoft/sp-core-library",\n  "docComment": "",\n  "name": "@microsoft/sp-core-library",\n  "members": [\n    {\n      "kind": "EntryPoint",\n      "canonicalReference": "",\n      "name": "",\n      "members": [\n        {\n          "kind": "Interface",\n          "canonicalReference": "(ILogHandler:interface)",\n          "docComment": "/**\\n * The redirectable implementation for the Log class.\\n *\\n * @beta\\n */\\n",\n          "releaseTag": "Beta",\n          "name": "ILogHandler",\n          "members": [\n            {\n              "kind": "MethodSignature",\n              "canonicalReference": "(error:0)",\n              "docComment": "",\n              "excerptTokens": [\n                {\n                  "kind": "Reference",\n                  "text": "error"\n                },\n                {\n                  "kind": "Content",\n                  "text": "("\n                },\n                . . .\n              ],\n              "returnTypeTokenRange": {\n                "startIndex": 10,\n                "endIndex": 11\n              },\n              "releaseTag": "Beta",\n              "overloadIndex": 1,\n              "parameters": [\n                {\n                  "parameterName": "source",\n                  "parameterTypeTokenRange": {\n                    "startIndex": 4,\n                    "endIndex": 5\n                  }\n                },\n                {\n                  "parameterName": "error",\n                  "parameterTypeTokenRange": {\n                    "startIndex": 8,\n                    "endIndex": 9\n                  }\n                }\n              ],\n              "name": "error"\n            },\n            . . .\n          ],\n          "extendsTokenRanges": []\n        },\n        . . .\n      ]\n    }\n  ]\n}\n')),(0,a.kt)("p",null,"Hmm, well that was interesting... but there's some good news: ",(0,a.kt)("strong",{parentName:"p"},"You don't need to write your own parser for this\ncomplex file format!")," The ",(0,a.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/@microsoft/api-extractor-model"},"@microsoft/api-extractor-model")," package already provides a complete library for reading,\nquerying, modifying, and writing this file format. If you want to roll your own TypeScript documentation generator,\nit's never been easier! :-)"),(0,a.kt)("h2",{id:"documenting-multiple-projects-together"},"Documenting multiple projects together"),(0,a.kt)("p",null,"A major advantage of this intermediary JSON file is that it allows a collection of related projects to be built\nseparately, but documented as a group. This is particularly useful at a large company, where individual\nprojects may be owned by different teams, perhaps working in separate Git repos, perhaps using different toolchains,\nperhaps releasing on different timelines. Regardless of how the JSON files are produced, once they are collected\ntogether in a central location, a tool such as ",(0,a.kt)("strong",{parentName:"p"},"api-documenter"),' can load them into a single "model" and generate\nan integrated website, complete with cross-package hyperlinks and an integrated navigation tree.'),(0,a.kt)("p",null,"This concludes our quick tour of the three major use cases for API Extractor. Ready to get started?"))}f.isMDXComponent=!0}}]);