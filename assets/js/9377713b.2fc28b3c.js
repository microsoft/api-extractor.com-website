"use strict";(self.webpackChunkapi_extractor_com=self.webpackChunkapi_extractor_com||[]).push([[5134],{158:(e,t,n)=>{n.d(t,{Zo:()=>l,kt:()=>h});var r=n(6393);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=r.createContext({}),c=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},l=function(e){var t=c(e.components);return r.createElement(p.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,p=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),m=c(n),d=o,h=m["".concat(p,".").concat(d)]||m[d]||u[d]||a;return n?r.createElement(h,i(i({ref:t},l),{},{components:n})):r.createElement(h,i({ref:t},l))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=d;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s[m]="string"==typeof e?e:o,i[1]=s;for(var c=2;c<a;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},7391:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>p,default:()=>h,frontMatter:()=>s,metadata:()=>c,toc:()=>m});var r=n(9122),o=n(2501),a=(n(6393),n(158)),i=["components"],s={title:"Integrating a custom doc pipeline"},p=void 0,c={unversionedId:"pages/setup/custom_docs",id:"pages/setup/custom_docs",title:"Integrating a custom doc pipeline",description:'_This article continues the tutorial from the "Invoking API Extractor" page.',source:"@site/docs/pages/setup/custom_docs.md",sourceDirName:"pages/setup",slug:"/pages/setup/custom_docs",permalink:"/pages/setup/custom_docs",draft:!1,editUrl:"https://github.com/microsoft/rushstack-websites/tree/main/websites/api-extractor.com/docs/pages/setup/custom_docs.md",tags:[],version:"current",frontMatter:{title:"Integrating a custom doc pipeline"},sidebar:"docsSidebar",previous:{title:"Generating API docs",permalink:"/pages/setup/generating_docs"},next:{title:"Getting Help",permalink:"/pages/setup/help"}},l={},m=[{value:"Forking the api-documenter project",id:"forking-the-api-documenter-project",level:2},{value:"Coding your own generator",id:"coding-your-own-generator",level:2}],u={toc:m},d="wrapper";function h(e){var t=e.components,n=(0,o.Z)(e,i);return(0,a.kt)(d,(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},'This article continues the tutorial from the "',(0,a.kt)("a",{parentName:"em",href:"/pages/setup/invoking"},"Invoking API Extractor"),"\" page.\nIt's recommended to start there.")),(0,a.kt)("p",null,"On the ",(0,a.kt)("a",{parentName:"p",href:"/pages/setup/generating_docs"},"previous page"),", we discussed various documentation systems that\ncan render the outputs created by the ",(0,a.kt)("strong",{parentName:"p"},"api-documenter")," tool. But what if you want a custom layout,\nor want to integrate with a totally different system? If you're not afraid of writing some code, API Extractor makes\nthis fairly straightforward."),(0,a.kt)("h2",{id:"forking-the-api-documenter-project"},"Forking the api-documenter project"),(0,a.kt)("p",null,"The ",(0,a.kt)("strong",{parentName:"p"},"api-documenter")," project was designed to serve as a code sample, so if you want to make some small changes,\nyou can simply fork it and modify the code. Here's the basic files you'd want to look at:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("a",{parentName:"p",href:"https://github.com/microsoft/rushstack/tree/main/apps/api-documenter"},"apps/api-documenter")," - the main\nproject folder on GitHub. This project is part of a ",(0,a.kt)("a",{parentName:"p",href:"https://rushjs.io/"},"Rush")," monorepo, but if you want to\nkeep things simple, you can run ",(0,a.kt)("inlineCode",{parentName:"p"},"npm install")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"npm run build")," in this folder and ignore all the other stuff.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("a",{parentName:"p",href:"https://github.com/microsoft/rushstack/blob/main/apps/api-documenter/src/cli/MarkdownAction.ts"},"MarkdownAction.ts")," -\nThis source file defines the ",(0,a.kt)("inlineCode",{parentName:"p"},"api-documenter markdown")," command-line and its parameters. It loads the ",(0,a.kt)("inlineCode",{parentName:"p"},"ApiModel"),"\nobject and passes it to ",(0,a.kt)("inlineCode",{parentName:"p"},"MarkdownDocumenter"),".")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("a",{parentName:"p",href:"https://github.com/microsoft/rushstack/blob/main/apps/api-documenter/src/documenters/MarkdownDocumenter.ts"},"MarkdownDocumenter.ts")," -\nThis is the main documentation generator that you'd want to study. It illustrates how to traverse the tree of\ndeclarations and render each TypeScript construct. Since the\n",(0,a.kt)("a",{parentName:"p",href:"https://github.com/microsoft/tsdoc/tree/master/tsdoc"},"TSDoc library")," already provides a nice API for representing\na tree of rich text elements, the ",(0,a.kt)("inlineCode",{parentName:"p"},"MarkdownDocumenter"),' class takes the approach of producing a huge TSDoc "comment"\nrepresenting each page on the web site. It\'s an unusual approach, but generating TSDoc output from TSDoc input\navoids having to transform all the inner content.')),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("a",{parentName:"p",href:"https://github.com/microsoft/rushstack/tree/main/apps/api-documenter/src/nodes"},"api-documenter/src/nodes")," -\nThis folder extends the TSDoc library with some custom node types for headings, tables, note boxes, etc.\nthat we need to make a full web page.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("a",{parentName:"p",href:"https://github.com/microsoft/rushstack/blob/main/apps/api-documenter/src/markdown/MarkdownEmitter.ts"},"MarkdownEmitter.ts"),' -\nThis class is the final stage that generates a Markdown document from our TSDoc "comment" (plus custom nodes).\nThis separation might enable modularity in the future: For example, if we wanted to support different Markdown\nflavors, the ',(0,a.kt)("inlineCode",{parentName:"p"},"MarkdownDocumenter")," class doesn't have to be concerned with that. Theoretically we could also\nemit entirely different output formats such as HTML from the same intermediary TSDoc node tree."))),(0,a.kt)("h2",{id:"coding-your-own-generator"},"Coding your own generator"),(0,a.kt)("p",null,"Looking over the above components, we see that most of this code is concerned with presentation of the\ndocumentation content. The main loop that visits all the API declarations and renders their various attributes\nis entirely contained in ",(0,a.kt)("inlineCode",{parentName:"p"},"MarkdownDocumenter.ts")," and is relatively small."),(0,a.kt)("p",null,"This is possible because of the ",(0,a.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/@microsoft/api-extractor-model"},"@microsoft/api-extractor-model")," library. It does the hard work of loading\nthe folder of .api.json files, parsing their contents, and providing a nice hierarchy that you can query.\nThe library also implements the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/microsoft/rushstack/blob/main/libraries/api-extractor-model/src/model/ApiModel.ts"},"ApiModel.resolveDeclarationReference()"),"\nfunction that you can use to resolve the declaration references such as ",(0,a.kt)("inlineCode",{parentName:"p"},"@link")," hyperlinks."),(0,a.kt)("p",null,"The README.md for ",(0,a.kt)("strong",{parentName:"p"},"@microsoft/api-extractor-model")," explains the basic hierarchy and how to traverse it,\nand the individual classes such as ",(0,a.kt)("inlineCode",{parentName:"p"},"ApiClass"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"ApiEnum"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"ApiInterface")," have pretty decent code comments."),(0,a.kt)("p",null,"One aspect that may not be entirely obvious is how to render TSDoc into some other format besides Markdown.\nFor an example of rendering HTML using React, you might also want to look at\n",(0,a.kt)("a",{parentName:"p",href:"https://github.com/microsoft/tsdoc/blob/master/playground/src/DocHtmlView.tsx"},"DocHtmlView.tsx"),'\nwhich renders the "HTML" tab for the ',(0,a.kt)("a",{parentName:"p",href:"https://microsoft.github.io/tsdoc/"},"TSDoc Playground"),"."),(0,a.kt)("p",null,"If you get stuck or have questions, the API Extractor developers are usually reachable\nin the ",(0,a.kt)("a",{parentName:"p",href:"https://rushstack.zulipchat.com/#narrow/stream/262521-api-extractor"},"Zulip chat room")," for the ",(0,a.kt)("strong",{parentName:"p"},"rushstack")," monorepo."),(0,a.kt)("p",null,"And if you implement an adapter that allows API Extractor to work with a cool open source documentation engine...\nlet us know! We'll definitely mention it in these docs! :-)"))}h.isMDXComponent=!0}}]);