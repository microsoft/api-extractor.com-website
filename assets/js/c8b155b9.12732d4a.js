"use strict";(self.webpackChunkapi_extractor_com=self.webpackChunkapi_extractor_com||[]).push([[152],{158:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>g});var o=n(6393);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=o.createContext({}),p=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return o.createElement(l.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(n),d=r,g=u["".concat(l,".").concat(d)]||u[d]||m[d]||a;return n?o.createElement(g,i(i({ref:t},c),{},{components:n})):o.createElement(g,i({ref:t},c))}));function g(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,i=new Array(a);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:r,i[1]=s;for(var p=2;p<a;p++)i[p]=n[p];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},2385:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>g,frontMatter:()=>s,metadata:()=>p,toc:()=>u});var o=n(9122),r=n(2501),a=(n(6393),n(158)),i=["components"],s={title:"Invoking API Extractor"},l=void 0,p={unversionedId:"pages/setup/invoking",id:"pages/setup/invoking",title:"Invoking API Extractor",description:"Sounds great! So... how exactly do we enable API Extractor for a new project?",source:"@site/docs/pages/setup/invoking.md",sourceDirName:"pages/setup",slug:"/pages/setup/invoking",permalink:"/pages/setup/invoking",draft:!1,editUrl:"https://github.com/microsoft/rushstack-websites/tree/main/websites/api-extractor.com/docs/pages/setup/invoking.md",tags:[],version:"current",frontMatter:{title:"Invoking API Extractor"},sidebar:"docsSidebar",previous:{title:"API documentation",permalink:"/pages/overview/demo_docs"},next:{title:"Configuring an API report",permalink:"/pages/setup/configure_api_report"}},c={},u=[{value:"Invoking via the command-line",id:"invoking-via-the-command-line",level:2},{value:"1. Configure the TypeScript compiler for your project",id:"1-configure-the-typescript-compiler-for-your-project",level:3},{value:"2. Install API Extractor",id:"2-install-api-extractor",level:3},{value:"3. Create a template config file",id:"3-create-a-template-config-file",level:3},{value:"4. Running the tool",id:"4-running-the-tool",level:3},{value:"Invoking from a build script",id:"invoking-from-a-build-script",level:2},{value:"Reusing settings across projects",id:"reusing-settings-across-projects",level:2}],m={toc:u},d="wrapper";function g(e){var t=e.components,n=(0,r.Z)(e,i);return(0,a.kt)(d,(0,o.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Sounds great! So... how exactly do we enable API Extractor for a new project?"),(0,a.kt)("h2",{id:"invoking-via-the-command-line"},"Invoking via the command-line"),(0,a.kt)("p",null,"The simplest way to invoke API Extractor is via the command-line."),(0,a.kt)("h3",{id:"1-configure-the-typescript-compiler-for-your-project"},"1. Configure the TypeScript compiler for your project"),(0,a.kt)("p",null,"For this tutorial, suppose we have a hypothetical library project whose ",(0,a.kt)("strong",{parentName:"p"},"package.json")," file looks like this:"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"awesome-widgets/package.json")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'{\n  "name": "awesome-widgets",\n  "version": "1.0.0",\n  "main": "./lib/index.js",\n  "typings": "./lib/index.d.ts"\n}\n')),(0,a.kt)("p",null,"Here we assume the library's main entry point is ",(0,a.kt)("strong",{parentName:"p"},"awesome-widgets/src/index.ts"),", which compiles to\nproduce the ",(0,a.kt)("strong",{parentName:"p"},"index.js")," and ",(0,a.kt)("strong",{parentName:"p"},"index.d.ts")," files seen above. In your ",(0,a.kt)("strong",{parentName:"p"},"tsconfig.json")," file, you should enable\nthe following settings:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},'"declaration": true')," - This enables generation of the .d.ts files that API Extractor will analyze.\n",(0,a.kt)("em",{parentName:"p"},"By design, TypeScript source files are not directly analyzed, but instead must be first processed by your compiler."))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},'"declarationMap": true')," - This enables generation of .d.ts.map files that allow API Extractor errors to be\nreported using line numbers from your original source files; without this, the error locations will instead\nrefer to the generated .d.ts files."))),(0,a.kt)("p",null,"Our example ",(0,a.kt)("strong",{parentName:"p"},"tsconfig.json")," file might look like this:"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"awesome-widgets/tsconfig.json")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'{\n  "$schema": "http://json.schemastore.org/tsconfig",\n  "compilerOptions": {\n    "target": "es5",\n    "module": "commonjs",\n    "declaration": true,\n    "sourceMap": true,\n    "declarationMap": true,\n    "types": [\n    ],\n    "lib": [\n      "es5"\n    ],\n    "outDir": "lib"\n  },\n  "include": [\n    "src/**/*.ts"\n  ]\n}\n')),(0,a.kt)("h3",{id:"2-install-api-extractor"},"2. Install API Extractor"),(0,a.kt)("p",null,"To install the NPM package in your global environment, use a command like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"$ npm install -g @microsoft/api-extractor\n")),(0,a.kt)("p",null,"Assuming your ",(0,a.kt)("inlineCode",{parentName:"p"},"PATH")," environment variable is set up correctly, now you should now be able to invoke the\n",(0,a.kt)("inlineCode",{parentName:"p"},"api-extractor")," tool from your shell."),(0,a.kt)("h3",{id:"3-create-a-template-config-file"},"3. Create a template config file"),(0,a.kt)("p",null,"Next, we need to create a config file ",(0,a.kt)("inlineCode",{parentName:"p"},"api-extractor.json")," for your project. The following command will create\n",(0,a.kt)("a",{parentName:"p",href:"https://github.com/microsoft/rushstack/blob/main/apps/api-extractor/src/schemas/api-extractor-template.json"},"a template file"),"\nthat shows all settings and their default values:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"$ api-extractor init\n")),(0,a.kt)("p",null,"We recommend to use this template for your real config file. However, since the template is fairly verbose,\nin this tutorial we will show condensed files without the extra comments.\n",(0,a.kt)("a",{parentName:"p",href:"/pages/configs/api-extractor_json"},"This page")," explains each setting in depth."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("strong",{parentName:"p"},"Comments in JSON files")),(0,a.kt)("p",{parentName:"blockquote"},"Strictly speaking, JSON was originally intended as a machine interchange format, and thus does not formally support\ncode comments. Recently JSON has gained popularity as a human-edited config file format, which obviously requires\ncomments. As such, most serious JSON libraries can handle comments without any trouble. (A notable exception\nis ",(0,a.kt)("inlineCode",{parentName:"p"},"JSON.parse()"),"; don't use that -- it cannot validate schemas and has poor error reporting.)"),(0,a.kt)("p",{parentName:"blockquote"},'VS Code highlights JSON comments as errors by default, but it provides an optional "',(0,a.kt)("a",{parentName:"p",href:"https://code.visualstudio.com/docs/languages/identifiers"},"JSON with comments"),"\" mode. To enable this, add this line to\nVS Code's ",(0,a.kt)("strong",{parentName:"p"},"settings.json"),":"),(0,a.kt)("pre",{parentName:"blockquote"},(0,a.kt)("code",{parentName:"pre",className:"language-json"},'"files.associations": { "*.json": "jsonc" }\n')),(0,a.kt)("p",{parentName:"blockquote"},"GitHub also highlights comments as errors by default. To fix that, add this line to your ",(0,a.kt)("strong",{parentName:"p"},".gitattributes")," file:"),(0,a.kt)("pre",{parentName:"blockquote"},(0,a.kt)("code",{parentName:"pre"},"*.json  linguist-language=JSON-with-Comments\n")),(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("em",{parentName:"p"},"For a discussion of some other possibilities, see\n",(0,a.kt)("a",{parentName:"em",href:"https://github.com/microsoft/rushstack/issues/1088"},"issue #1088"),"."))),(0,a.kt)("p",null,'Our convention is to put config files in the "config" subfolder, so folder tree might look like this:'),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"awesome-widgets/package.json"),(0,a.kt)("li",{parentName:"ul"},"awesome-widgets/tsconfig.json"),(0,a.kt)("li",{parentName:"ul"},"awesome-widgets/config/api-extractor.json"),(0,a.kt)("li",{parentName:"ul"},"awesome-widgets/lib/index.d.js"),(0,a.kt)("li",{parentName:"ul"},"awesome-widgets/lib/index.js.map"),(0,a.kt)("li",{parentName:"ul"},"awesome-widgets/lib/index.d.ts"),(0,a.kt)("li",{parentName:"ul"},"awesome-widgets/lib/index.d.ts.map"),(0,a.kt)("li",{parentName:"ul"},"awesome-widgets/src/index.ts")),(0,a.kt)("p",null,'If your project doesn\'t use the "config" subfolder convention, you can also put ',(0,a.kt)("strong",{parentName:"p"},"api-extractor.json")," in your\nproject folder. API Extractor will look for it in both places."),(0,a.kt)("p",null,"In the next few pages, we'll look at the individual settings in more detail. For now, we should simply make sure\nthat the ",(0,a.kt)("inlineCode",{parentName:"p"},"mainEntryPointFilePath")," matches the ",(0,a.kt)("inlineCode",{parentName:"p"},'"typings"')," field in our ",(0,a.kt)("strong",{parentName:"p"},"package.json")," file above. The template\nassigns it like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'  "mainEntryPointFilePath": "<projectFolder>/lib/index.d.ts",\n')),(0,a.kt)("p",null,"...which matches the ",(0,a.kt)("strong",{parentName:"p"},"package.json")," ",(0,a.kt)("inlineCode",{parentName:"p"},'"typings"')," field above."),(0,a.kt)("h3",{id:"4-running-the-tool"},"4. Running the tool"),(0,a.kt)("p",null,"Now we're ready to invoke the ",(0,a.kt)("strong",{parentName:"p"},"api-extractor")," command line. For a local (non-production) build, you would\nuse these shell commands:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"$ cd awesome-widgets\n\n# First invoke the TypeScript compiler to make the .d.ts files\n$ tsc\n\n# Next, we invoke API Extractor\n$ api-extractor run --local --verbose\n")),(0,a.kt)("p",null,"If you're having trouble, the ",(0,a.kt)("inlineCode",{parentName:"p"},"--diagnostics")," option prints additional information that can help to diagnose the\nissue."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"# Print troubleshooting logs\n$ api-extractor run --local --diagnostics\n")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("strong",{parentName:"p"},"Compiler version incompatibilities")),(0,a.kt)("p",{parentName:"blockquote"},"When API Extractor invokes the compiler engine to analyze your project, it uses its own TypeScript version. It\ncannot use your toolchain's version because the compiler engine API may be incompatible. This sometimes causes\nAPI Extractor to report compiler errors due to differences in the system typings between TypeScript versions.\nYou can avoid this by specifying the ",(0,a.kt)("inlineCode",{parentName:"p"},"--typescript-compiler-folder")," command-line option\n(",(0,a.kt)("inlineCode",{parentName:"p"},"IExtractorInvokeOptions.typescriptCompilerFolder")," in the API). This enables API Extractor to use\nthe system typings from your toolchain's TypeScript folder."),(0,a.kt)("p",{parentName:"blockquote"},"If the issue is that your toolchain uses a newer compiler release than API Extractor's engine, please\nopen a GitHub issue requesting to upgrade API Extractor's compiler. We try to stay as current as possible.")),(0,a.kt)("h2",{id:"invoking-from-a-build-script"},"Invoking from a build script"),(0,a.kt)("p",null,"If your project is built using a custom toolchain that is coded in TypeScript, you can alternatively invoke\nthe API Extractor engine programmatically."),(0,a.kt)("p",null,"There are a lot of options, but here's a bare bones example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import * as path from 'path';\nimport { Extractor, ExtractorConfig, ExtractorResult } from '@microsoft/api-extractor';\n\nconst apiExtractorJsonPath: string = path.join(__dirname, '../config/api-extractor.json');\n\n// Load and parse the api-extractor.json file\nconst extractorConfig: ExtractorConfig = ExtractorConfig.loadFileAndPrepare(apiExtractorJsonPath);\n\n// Invoke API Extractor\nconst extractorResult: ExtractorResult = Extractor.invoke(extractorConfig, {\n  // Equivalent to the \"--local\" command-line parameter\n  localBuild: true,\n\n  // Equivalent to the \"--verbose\" command-line parameter\n  showVerboseMessages: true\n});\n\nif (extractorResult.succeeded) {\n  console.log(`API Extractor completed successfully`);\n  process.exitCode = 0;\n} else {\n  console.error(\n    `API Extractor completed with ${extractorResult.errorCount} errors` +\n      ` and ${extractorResult.warningCount} warnings`\n  );\n  process.exitCode = 1;\n}\n")),(0,a.kt)("p",null,"If you invoke API Extractor multiple times for a single ",(0,a.kt)("strong",{parentName:"p"},"tsconfig.json")," environment, this approach also allows\nyou to reuse the same ",(0,a.kt)("inlineCode",{parentName:"p"},"CompilerState")," object across multiple invocations. This can be a significant performance\noptimization, since the TypeScript compiler analysis is relatively expensive. Take a look at the\n",(0,a.kt)("a",{parentName:"p",href:"https://github.com/microsoft/rushstack/blob/main/build-tests/api-extractor-scenarios/src/runScenarios.ts"},"api-extractor-scenarios/src/runScenarios.ts"),"\ntest runner for a real world example of how to do this."),(0,a.kt)("h2",{id:"reusing-settings-across-projects"},"Reusing settings across projects"),(0,a.kt)("p",null,"The ",(0,a.kt)("strong",{parentName:"p"},"api-extractor.json")," file contents are completely described by the ",(0,a.kt)("inlineCode",{parentName:"p"},"IConfigFile")," interface, which you\ncan use to construct the ",(0,a.kt)("inlineCode",{parentName:"p"},"ExtractorConfig")," object. With this approach it's possible to avoid creating an\n",(0,a.kt)("strong",{parentName:"p"},"api-extractor.json")," file entirely, but we generally recommend not to do that. When developers are\ntroubleshooting problems, it's very useful to have your actual configuration represented in a standard config file\nthat people can inspect and tinker with. Also, if you ever need to debug API Extractor itself,\nit's probably easer to debug the isolated ",(0,a.kt)("inlineCode",{parentName:"p"},"api-extractor")," process than a complex toolchain, but you'll need an\n",(0,a.kt)("strong",{parentName:"p"},"api-extractor.json")," file for that."),(0,a.kt)("p",null,"So... if you work in a modern monorepo with many different projects, how can you ensure they have consistent\nAPI Extractor settings without a lot of copy+pasting of ",(0,a.kt)("strong",{parentName:"p"},"api-extractor.json")," files? Following the\nconvention of ",(0,a.kt)("strong",{parentName:"p"},"tsconfig.json")," and ",(0,a.kt)("strong",{parentName:"p"},"tslint.json"),", API Extractor supports an ",(0,a.kt)("inlineCode",{parentName:"p"},'"extends"')," field that allows\nyour ",(0,a.kt)("strong",{parentName:"p"},"api-extractor.json")," file to inherit its configuration from a shared template file.\n",(0,a.kt)("a",{parentName:"p",href:"/pages/configs/api-extractor_json#extends"},"See here")," for details."),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"Now that we've got things running, let's look at how to configure the three different output types...")))}g.isMDXComponent=!0}}]);